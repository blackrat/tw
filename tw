#!/usr/bin/env ruby
require 'rubygems'
require 'oauth'
require 'twitter'
require 'yaml'
require 'time'
require 'rainbow'

class Tw

  class Error < StandardError
  end

  attr_reader :conf

  def initialize(conf_file = "#{ENV['HOME']}/.tw.conf")
    @conf_file = conf_file
    unless File.exists?(@conf_file)
      open(@conf_file, 'w+'){|f|
        f.puts <<-EOF
consumer_key: AYhhkOC8H2yTZyelz3uw
consumer_secret: 28Ba8YyFDSPgoCYAmH5ANqOmT6qVS8gIhKnUiDbIpU
confirm_tweet: true # true/false
EOF
      }
      puts "config file => #{@conf_file}"
    end
    @conf = YAML.load open(@conf_file).read
    
    auth
  end

  def auth
    if !@conf['access_token'] or !@conf['access_secret']
      consumer = OAuth::Consumer.new(@conf['consumer_key'], @conf['consumer_secret'],
                                     :site => 'http://twitter.com')
      begin
        request_token = consumer.get_request_token
        puts "open #{request_token.authorize_url}"
        system "open #{request_token.authorize_url}"
        print 'input PIN Number: '
        oauth_verifier = gets.strip
        access_token = request_token.get_access_token(:oauth_verifier => oauth_verifier)
        @conf['access_token'] = access_token.token
        @conf['access_secret'] = access_token.secret
      rescue => e
        raise Error.new "#{e.to_s}\ncheck config file(#{@conf_file}) and twitter.com status."
      end
      open(@conf_file,'w+'){|f|
        f.puts @conf.to_yaml
      }
    end

    Twitter.configure do |config|
      config.consumer_key = @conf['consumer_key']
      config.consumer_secret = @conf['consumer_secret']
      config.oauth_token = @conf['access_token']
      config.oauth_token_secret = @conf['access_secret']
    end
  end

  def mentions
    Twitter.mentions.map{|m|
      {
        :id => m.id,
        :user => m.user.screen_name,
        :text => m.text,
        :time => m.created_at
      }
    }
  end

  def search(word)
    Twitter.search(word).map{|m|
      {
        :id => m.id,
        :user => m.from_user,
        :text => m.text,
        :time => m.created_at
      }
    }
  end

  def user_timeline(user)
    Twitter.user_timeline(user).map{|m|
      {
        :id => m.id,
        :user => m.user.screen_name,
        :text => m.text,
        :time => m.created_at
      }
    }
  end

  def list_timeline(user,list)
    Twitter.list_timeline(user, list).map{|m|
      {
        :id => m.id,
        :user => m.user.screen_name,
        :text => m.text,
        :time => m.created_at
      }
    }
  end

  def tweet(message)
    res = Twitter.update message
    puts res.text
    puts "http://twitter.com/#{res.user.screen_name}/status/#{res.id}"
    puts res.created_at
  end

  def self.search_word?(str)
    str =~ /^\?.+$/ ? str.scan(/^\?(.+)$/)[0][0] : false
  end

  def self.username?(str)
    str =~ /^@[a-zA-Z0-9_]+$/ ? str.scan(/^@([a-zA-Z0-9_]+)$/)[0][0] : false
  end

  def self.listname?(str)
    if str =~ /^@[a-zA-Z0-9_]+\/[a-zA-Z0-9_]+$/
      return str.scan(/^@([a-zA-Z0-9_]+)\/([a-zA-Z0-9_]+)$/).first
    end
    false
  end

  def self.cmd?(str)
    search_word?(str) ||  username?(str) || listname?(str)
  end

  def self.all_cmds?(argv)
    argv.map{|arg| Tw.cmd? arg}.count(false) < 1
  end

  def self.color_code(str)
    colors = Sickill::Rainbow::TERM_COLORS.keys - [:default, :black, :white]
    n = str.each_byte.map{|c| c.to_i}.inject{|a,b|a+b}
    return colors[n%colors.size]
  end

  def self.display(hash)
    hash.flatten.sort{|a,b|
      a[:id] <=> b[:id]
    }.uniq.each{|m|
      line = "#{m[:time].strftime '[%m/%d %a] (%H:%M:%S)'} @#{m[:user]} : #{m[:text]}"
      puts line.split(/(@[a-zA-Z0-9_]+)/).map{|term|
        if term =~ /@[a-zA-Z0-9_]+/
          term = term.color(color_code term).bright.underline
        end
        term
      }.join('')
    }
  end
end


if __FILE__ == $0
  tw = Tw.new

  if ARGV.size < 1
    Tw.display tw.mentions
  elsif Tw.all_cmds? ARGV
    Tw.display ARGV.map{|arg|
      if word = Tw.search_word?(arg)
        res = tw.search word
      elsif user = Tw.username?(arg)
        res = tw.user_timeline user
      elsif (user, list = Tw.listname?(arg)) != false
          res = tw.list_timeline(user, list)
      end
      res
    }
  else
    if ARGV.size == 1 and ARGV.first =~ /^-+$/
      ARGF.each do |line|
        line.split(/(.{140})/u).select{|m|m.size>0}.each do |message|
          tw.tweet message
        end
        sleep 1
      end
    else
      message = ARGV.join(' ')
      if tw.conf['confirm_tweet']
        if (len = message.split(//u).size) > 140
          puts "tweet too long (#{len} chars)"
          exit 1
        else
          puts "tweet \"#{message}\"?  (#{len} chars)"
          puts '[Y/n]'
          exit if STDIN.gets.strip =~ /^n/i
        end
      else
        puts "tweet \"#{message}\""
      end
      tw.tweet message
    end
  end
end
  
