#!/usr/bin/env ruby
require 'rubygems'
require 'oauth'
require 'twitter'
require 'yaml'


CONF_FILE = "#{ENV['HOME']}/.tw.conf"


## conf
unless File.exists?(CONF_FILE)
  open(CONF_FILE, 'w+'){|f|
    f.puts <<-EOF
# regist your app on twitter(http://twitter.com/apps) to get KEY and SECRET
consumer_key: your-consumer-key
consumer_secret: your-consumer-secret
EOF
  }
  system "#{ENV['EDITOR']} #{CONF_FILE}"
  puts "config file => #{CONF_FILE}"
end

conf = YAML.load open(CONF_FILE).read

## auth
if !conf['access_token'] or !conf['access_secret']
  consumer = OAuth::Consumer.new(conf['consumer_key'], conf['consumer_secret'],
                                :site => 'http://twitter.com')
  begin
    request_token = consumer.get_request_token
    puts "open #{request_token.authorize_url}"
    system "open #{request_token.authorize_url}"
    print 'input PIN Number: '
    oauth_verifier = gets.strip
    access_token = request_token.get_access_token(:oauth_verifier => oauth_verifier)
    conf['access_token'] = access_token.token
    conf['access_secret'] = access_token.secret
  rescue => e
    STDERR.puts e
    puts "check config file(#{CONF_FILE}) and twitter.com status."
    exit 1
  end
  open(CONF_FILE,'w+'){|f|
    f.puts conf.to_yaml
  }
end


## tweet
Twitter.configure do |config|
  config.consumer_key = conf['consumer_key']
  config.consumer_secret = conf['consumer_secret']
  config.oauth_token = conf['access_token']
  config.oauth_token_secret = conf['access_secret']
end

if ARGV.size < 1
  begin
    Twitter.mentions.sort{|a,b|
      a.id <=> b.id
    }.each{|m|
      puts "#{m.user.screen_name} : #{m.text} - #{m.created_at}"
    }
  rescue => e
    STDERR.puts e
  end
  exit
end

argv_username = ARGV.map{|arg| arg =~ /^@[a-zA-Z0-9_]+$/ }
if argv_username.count(0) > 0 and argv_username.count(nil) < 1
  begin
    ARGV.map{|name|
      Twitter.user_timeline(name.scan(/@(.+)/).first.first)
    }.flatten.sort{|a,b|
      a.id <=> b.id
    }.each{|m|
      puts "#{m.user.screen_name} : #{m.text} - #{m.created_at}"
    }
  rescue => e
    STDERR.puts e
  end
  exit
end

argv_listname = ARGV.map{|arg| arg =~ /^@[a-zA-Z0-9_]+\/[a-zA-Z0-9_]+$/ }
if argv_listname.count(0) > 0 and argv_listname.count(nil) < 1
  ARGV.map{|arg|
    user, listname = arg.scan(/^@([a-zA-Z0-9_]+)\/([a-zA-Z0-9_]+)$/).first
    Twitter.list_timeline(user, listname)
  }.flatten.uniq.sort{|a,b|
    a.id <=> b.id
  }.each{|m|
    puts "#{m.user.screen_name} : #{m.text} - #{m.created_at}"
  }
  exit
end

begin
  message = ARGV.join(' ')
  puts "tweet \"#{message}\"?"
  puts '[Y/n]'
  exit 1 if STDIN.gets.strip =~ /^n/i
  res = Twitter.update message
  puts res.text
  puts "http://twitter.com/#{res.user.screen_name}/status/#{res.id_str}"
  puts res.created_at
rescue => e
  STDERR.puts e
end

